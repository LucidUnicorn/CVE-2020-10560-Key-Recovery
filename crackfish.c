#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <openssl/md5.h>
#include <openssl/blowfish.h>
#include "base64/base64.h"

#define KEY_LENGTH 20
#define SUBSTR_START 3
#define SUBSTR_LENGTH 8

struct generator_args {
    long min;
    long max;
};

pthread_mutex_t lock;
int attempts_per_second = 0;
int key_found = 0;
const unsigned char *ciphertext = "VljhmliGbxZ0VwvdlZdRyM4Y0dIKixzVCwEnh/0rr7HCITrn4IXStA==";

char *build_cycled_key(char *key) {
    char *cycled_key = malloc(KEY_LENGTH + 1);
    memset(cycled_key, 0, KEY_LENGTH + 1);
    
    while (strlen(cycled_key) < KEY_LENGTH) {
        int concat_size = KEY_LENGTH - strlen(cycled_key);

        if (concat_size > strlen(key)) {
            concat_size = strlen(key);
        }

        strncat(cycled_key, key, concat_size);
    }

    return cycled_key;
}

void *test_attempt(void *args) {
    pthread_mutex_lock(&lock);
    attempts_per_second++;
    pthread_mutex_unlock(&lock);
    char *str_key = build_cycled_key((char *) args);
    BF_KEY *bf_key = malloc(sizeof(BF_KEY));
    unsigned char *encrypted_bytes = malloc(1024);
    unsigned char *result = malloc(1024);
    int decoded_byte_count;
    
    memset(encrypted_bytes, 0, 1024);
    memset(result, 0, 1024);
    decoded_byte_count = b64_decode(ciphertext, strlen(ciphertext), encrypted_bytes);

    BF_set_key(bf_key, KEY_LENGTH, str_key);
    unsigned char *result_next = result;
    unsigned char *eb_pointer = encrypted_bytes;

    while (decoded_byte_count) {
        BF_ecb_encrypt(eb_pointer, result_next, bf_key, BF_DECRYPT);
        eb_pointer += 8;
        result_next += 8;
        decoded_byte_count -= 8;
    }
   
    if (strstr(result, "tmp/photos") != NULL) {
        printf("Key found: %s Message: %s\n", str_key, result);
        pthread_mutex_lock(&lock);
        key_found = 1;
        pthread_mutex_unlock(&lock);
    }

    free(str_key);
    free(args);
    free(encrypted_bytes);
    free(result);
    free(bf_key);
}

void *attempt_generator(void *arguments) {
    struct generator_args *args = malloc(sizeof(struct generator_args));
    args = arguments;
    pthread_t threads[5000];
    int thread_index = 0;

    for (long i = args->min; i <= args->max; i++) {
        if (key_found) {
            return;
        }

        char *string = malloc(256);
        unsigned char hash[MD5_DIGEST_LENGTH];
        char *attempt = malloc(SUBSTR_LENGTH + 1);
        char *hash_hex = malloc(32);

        memset(string, 0, 256);
        memset(attempt, 0, SUBSTR_LENGTH + 1);
        memset(hash_hex, 0, 32);
        sprintf(string, "ossn%ld", i);
        MD5(string, strlen(string), hash);

        for (int j = 0; j < MD5_DIGEST_LENGTH; j++) {
            hash_hex += sprintf(hash_hex, "%02x", hash[j]);
        }

        hash_hex -= 32;
        strncpy(attempt, hash_hex + SUBSTR_START, SUBSTR_LENGTH);
        pthread_create(&threads[thread_index], NULL, test_attempt, attempt);
       
        if (thread_index == 4999) {
            for (int j = 0; j < sizeof(threads) / sizeof(threads[0]); j++) {
                pthread_join(threads[j], NULL);
            }

            thread_index = 0;
        } else {
            thread_index++;
        }

        free(hash_hex);
        free(string);
    }

    for (int i = 0; i < sizeof(threads) / sizeof(threads[0]); i++) {
        pthread_join(threads[i], NULL);

        if (key_found) {
            return;
        }
    }
}

void *progress_thread() {
    time_t base_time = time(NULL);

    while (1) {
        if (key_found) {
            return;
        } else if (difftime(time(NULL), base_time) >= 1.0) {
            printf("Attempts per second: %d\n", attempts_per_second);
            base_time = time(NULL);
            pthread_mutex_lock(&lock);
            attempts_per_second = 0;
            pthread_mutex_unlock(&lock);
        } else {
            usleep(100 * 1000);
        }
    }
}

void start_generators(long max_value, int thread_count) {
    pthread_t threads[thread_count];
    struct generator_args args[thread_count];

    while (max_value % thread_count != 0) {
        max_value++;
    }
    
    for (int i = 0; i < thread_count; i++) {
        args[i].max = (max_value / thread_count) * (i + 1);
        args[i].min = (max_value / thread_count) * i;

        if (args[i].min > 0) {
            args[i].min++;
        }

        pthread_create(&threads[i], NULL, attempt_generator, &args[i]);
    }
   
    for (int i = 0; i < thread_count; i++) {
        pthread_join(threads[i], NULL);
    }
}


int main() {
    setbuf(stdout, NULL);
    time_t start_time = time(NULL);
    pthread_t progress_monitor;
    pthread_create(&progress_monitor, NULL, progress_thread, NULL);
    start_generators(2147483647, 4);
    pthread_join(progress_monitor, NULL);
    printf("Time taken: %f\n", difftime(time(NULL), start_time));
    return 0;
}
